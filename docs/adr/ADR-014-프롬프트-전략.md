# ADR-014: PromptContextBuilder(8000자) 유지 + 사고 프레임 분리 전략


## 상태
Accepted

## 결정 시점
2026-01-16

## 배경

DevTalk은 개발 중 발생한 문제 해결 과정을 기록 자산으로 남기는 도구이며,
AI는 자동 해결자가 아니라 **사고를 보조하는 기록 생성기**로 사용한다.

초기 구현에서는 다음과 같은 구조를 사용했다.

- 메세지를 입력하면 저장
- 세션 메시지를 최대 8000자까지 잘라 컨텍스트로 생성(보낸 메세지도 함께 저장)
- 매 AI 요청마다 해당 컨텍스트를 전달

이 구조는 간단하 질문을 하더라도 응답이 잘리게 되는 결과가 나오게 되었다.

- 출력이 중간에 잘리거나 1개 항목만 생성되는 현상
- 유저가 프롬프트 사용법을 알아야 하는 상태로 전락
- “서비스”가 아니라 “프롬프트 도구”에 가까워짐

## 문제 정의

문제의 핵심은 다음과 같다.

> 출력 안정화(잘림 방지)와 사고 지원(디버깅/추론)을
> 동일한 프롬프트 계층에서 동시에 해결하려고 시도했다.

그 결과:
- 형식 강제는 강화되었지만
- AI의 사고 전개는 최소 충족 응답으로 수렴
- 특히 Gemini 모델 특성상 “예시 1개만 생성하고 종료”하는 현상이 빈번히 발생

## 결정

다음과 같은 설계 원칙을 채택한다.

### 1. 8000자 컨텍스트 유지
- 기존 PromptContextBuilder(최대 8000자 유지 로직)는 **그대로 유지한다**
- 다만, 이 컨텍스트는 더 이상 “매 AI 요청에 직접 전달되는 사고 프롬프트”가 아니다
- 컨텍스트는 **사실 묶음(Context Snapshot)** 역할만 수행한다

### 2. 사고 프레임과 출력 안정화의 분리
- 출력 안정화(잘림 방지, 형식 최소 보장)는 System/Validator 레이어의 책임
- 사고 방식(요약, 디버깅, 원인 분석 등)은 Task Prompt 레이어의 책임
- 유저는 사고 방식이나 형식을 알 필요가 없다

### 3. 질문 유형(Task Type) 도입
모든 AI 요청은 명시적인 Task Type을 가진다.

초기에는 다음 두 가지만 사용한다.

- SUMMARY
  - 목적: 빠른 파악, 학습 정리
  - 특징: 개수 고정 가능, 짧은 문장
- DEBUG
  - 목적: 의심 지점 도출 및 근거 제시
  - 특징: 개수 가변, “의심 + 근거” 구조
  - 번호는 목록이 아니라 **가설 ID**의 의미를 가진다

### 4. DEBUG에서는 개수 강제 금지
- 디버깅은 본질적으로 가변적이므로 “정확히 N개” 강제를 제거한다
- 대신 상한(max N)만 둘 수 있다
- Validator는 형식 붕괴만 검증하며 사고 내용의 옳고 그름은 판단하지 않는다

### 5. 유저 프롬프트 단순화
- 유저 입력은 오직 “의미”만 담는다
- 형식, 개수, 사고 방식은 전부 시스템이 결정한다
- 프롬프트 엔지니어링을 유저에게 요구하지 않는다

## 결과

### 변경된 역할 정리

- PromptContextBuilder
  - 세션 로그를 기반으로 사실 묶음(Context Snapshot) 생성
  - 사고 유도/출력 형식 제어 책임 제거

- System Prompt
  - 출력 안정성, 최소 형식 보장 담당

- Task Prompt
  - 질문 유형별 사고 프레임 담당 (SUMMARY / DEBUG)

- Validator
  - 출력 잘림, 형식 완전 붕괴 여부만 검증
  - 사고 내용의 품질은 검증하지 않음

### 기대 효과

- 출력 잘림 문제와 사고 품질 문제를 분리하여 해결
- 디버깅 질문에서 자연스러운 사고 전개 가능
- 유저가 프롬프트를 배울 필요 없는 “서비스형 AI”로 진화
- Gemini 모델 특성(최소 충족 응답)에 대한 구조적 대응 가능

## 트레이드오프

- Task Prompt 및 Validator 구현 비용 증가
- 질문 유형 분류 로직 필요
- 초기 설계 복잡도 증가

그러나 이는 DevTalk의 장기적인 기록 자산 가치와
AI 서비스로서의 일관성을 위해 감수할 수 있는 비용으로 판단한다.
